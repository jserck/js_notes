//首先说明什么是词法作用域，程序在编译的第一个阶段就是词法分析阶段，在这个时候，
//在代码编写的时候，所生成的作用域就是词法作用域，也就是说，词法作用域是你代码写完以后
//就已经定义好的回顾作用域里面的例子：
function foo(a) {
        var b = a * 2;
        function bar(c) {
                console.log(a, b, c);
        }
        bar(b * 3);
}
foo(2);
//上面逐级嵌套的两个函数分别创建了自己的作用域，并且是在函数编写的时候就已经定义好的，
//当引擎去执行的时候默认会根据词法作用域进行查找,
//那么问题来了，万一有代码修改了词法作用域会怎么样，往下看

//eval
//eval这个函数大家都不陌生，他的功能就是可以把参数里面传递的字符串当做js代码来执行，
//在强大的功能的背后，也暴露了它的本质
function foo(str, a) {
        eval(str);
        console.log(b, a);
}
var b = 2;
foo('var b = 3', 1);//3,1
//问题来了，根据词法作用域的机制，对b进行RHS查询的时候，在当前的作用域里边没有找到，会逐级向上查找，知道找到
//全局里面定义的b，输出2,1，其实eval在函数内部执行的时候，修改了词法作用域，当此法解析的时候，编译器并不会认为
//str是一个JS代码，他就是字符串，所以在当时的词法作用域里边是没有b这个标识符的，但是当引擎执行了这段代码之后，
//b就被声明到了当前的词法作用域里边，并且遮蔽了全局的b，这就是eval欺骗词法的效果，另外一个，请看下面：
function bar(obj) {
        with (obj) {
                a = 2
        }
}
var o1 = {
        a: 1
}
var o2 = {
        b: 1
}
bar(o1);
console.log(o1.a);//2
bar(o2);
console.log(o2.a);//undefined
console.log(a);//2
//我擦，a又特么泄露到全局惹，为啥子呢，其实啊，with函数在创建的时候，在bar函数内部，新建了一个词法作用域，注意，他跟eval不同
//eval是修改了词法作用域，with这货是直接创建了一个词法作用域，这就导致在新建的词法作用域里边，没有找到a标识符，就会已经词法作用域的
//查找机制向上查找，并且在全局创建，但是用var声明的a页并不会局限在with创建的词法作用域里边，而是暴露在了with所在的作用域里边，
//这就尴尬了，你说他新建一个作用域也就算了，又保证不了词法作用域的安全，也不能局限作用域里边的标识符，
//这就是百害无一利啊
//所以eval跟with会自然的造成一些性能的问题，最终导致运行过慢，并且JS的优化也是无用的！

