//在说此法作用于之前，先回顾下上一章的LHS or RHS查询机制。
//我们都知道一段代码在之前之前都会先进行编译，玉传统的编译语言不通，
//js的编译发生在执行之前的几微妙的时候甚至会更短，js会利用一些方法，
//进行延迟编译或者重复编译，让性能更好。那么当引擎去执行这段代码的时候，
//需要与作用域进行对话，已确定当前要执行的代码里面的标识符是否有访问权限
//这样就产生了查询机制，例如下面的例子：
function foo(a) {
        var b = a;
        return a + b;
}
var c = foo(2);
console.log(c);

//首先编译器在对代码进行编译之后，通常已经做好了要执行的准备，
//当引擎去执行的时候他会与作用域进行一次对话，如下：
//引擎：作用域兄弟，我要对C进行一次LHS查询，你见过他么？
//作用域：见过大兄弟，编译器那小子刚刚把C声明成了一个变量，拿去。
//引擎：谢谢大兄弟，对了，下面这个foo是什么鬼，我需要对他进行RHS查询，然后赋值给C
//作用域：哦，这个啊，foo是一个函数，给你。
//引擎：谢啦，既然他是一个函数，那我就先来执行一下他把，哎，里面有个A，我需要对他进行LHS查询，
//作用域：噢对了，A是这个函数隐式声明的一个参数，
//引擎：噢，你这说我就知道了，那我把这个2给他赋值。
//引擎：这个B是什么啊，我要对他进行LHS查询。
//作用域：B是编译器那小子在函数里面声明的一个变量，拿去
//引擎：OLOL，那后面这个A有点熟悉啊，需要对他进行RHS查询，是刚才那个A么？
//作用域：对对，就是刚才那个。
//引擎：好累，下面我分别对a跟b进行一次RHS查询，并且把他俩加起来赋给C吧，这样就算执行完毕了

//作用域嵌套
//上面的函数跟对话很明了的说明了作用域在一个程序中的重要性，可以说是必不可少的，但是当遇到两个
//或者多个作用域该怎么处理呢，
//看线面的例子：

function foo(a) {
        var b = a * 2;
        function bar(c) {
                console.log(a, b, c);
        }
        bar(b * 3);
}
foo(2);

//首先可以把逐级嵌套的作用域当成一层层的建筑，当前作用域就是一楼，假设代码执行到了bar();
//首先对bar进行一次RHS查询，对参数B进行RHS查询，当执行到console.log的时候，在第一层，并没有找到a，因为a
//是在上一层，也就是说第二层楼，所以就是到上一层去查找a，如果上一层也没有，就会逐级查找，知道作用域的尽头，全局！
//另外，还又一点很重要，LHS和RHS查询异常的表现是不一样的，比如：
function foo() {
        var a = b + 1
}
function bar() {
        a = 1;
}
foo()//ReferenceError: b is not defined
bar()
console.log(a) //1  糟糕，a被泄漏到了全局
//上诉结果可以看到，对b进行RHS查询的时候，由于在当前作用域和全局作用域并没有找到b所以爆了ReferenceError错误
//但是对a进行LHS查询的时候，虽然在全局没有找到，但是确把a定义成了全局的属性，window.a
//由此可以看出LHS查询和RHS查询的差别
