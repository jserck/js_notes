//函数作用域
//顾名思义，函数在创建的时候会形成自己的作用域，在函数作用域声明的标识符，在作用域外部是无法直接访问的，
function foo(params) {
        var a = bar();
        return a;
}
function bar(params) {
        return 3;
}
foo();
//上面的代码看似没什么问题，但是，很明显，暂时只有foo函数用到了bar，但是bar函数却声明在全局，
//这就导致了很可能会造成全局污染，并且增加内存的消耗量，下面是修改后的版本：
function foo(params) {
        var a = bar();
        return a;
        function bar(params) {
                return 3;
        }
}
//自习看修改完的代码，bar函数变成了foo函数作用域私有的函数，所以，便不会造成全局的污染；
//还有一点需要注意，就是规避冲突，看下面代码：
function foo(params) {
        function bar(params) {
                i = 3;
                console.log(i);
        }
        for (var i = 0; i < 9; i++) {
                bar();
        }
}
foo();
//你猜上面的代码会怎么样，没错，会死循环，因为bar函数里面直接修改了for代码里面的i值，导致i永远满足
//小于9
//函数的作用域存在就是可以避免命名冲突的发生，用函数来包裹需要规避的标识符，变成函数的私有标识符，
//但是呢，函数本身的命名就是一个全局的污染，所以这种方法并不理想，怎么改进呢：
(function foo(params) {
        var a = 1;
        var b = 2;
})();
console.log(a, b);
//利用明明函数，既可以保证标识符的隐蔽性，又可以避免函数本身对作用域的污染，因为自执行函数其实是一个表达式来执行的，
//所以并不能把他当成一个真正的函数。
//那么接下来说一下匿名函数和具名函数，
//顾名思义，匿名函数就是没有函数名的函数，具名函数就是有函数名的函数，
//比如settimeout  等得回调函数类型，普遍都是匿名函数形式，而普通的函数呢，普遍都是具名函数，因为他们有自己的函数名，
//并且可以通过函数名来调用自己，不过换是推荐使用具名函数，不管是回调函数，还是什么函数
//因为相对于具名函数，匿名函数有很多的不足：
//1,匿名函数没有名字，在内存中保存没有具体的标识可以区分
//2,匿名函数无法调用自身，除了anguments,callee，但是这个方法已被弃用
//3,代码的维护和可读性不强
//自执行函数又称为IIFE函数，除了可以规避冲突外，还可以传递参数，形成一个封闭的有效的执行空间并且实现一些很有用的功能，
//比如：
undefined = true;
//如果代码外面有undefined的标识符，很容易给其他人挖一个大坑，所以要这样：
(function foo(undefined) {
        if (a = undefined) {
                // ...
        }
})();
//上面的代码就是一个有效的undefined
//除了函数作用域，最常见的就是块作用域，
//块作用域典型的例子就是for循环，块作用域跟函数作用域功能上其实是没什么区别的，都可以有效的规避命名冲突，
//也就是说，一个只在内部使用的标识符，为什么要把他暴露在全局呢，所以，最好就是要跟使用它的代码越近越好，（大白话）
var foo = true;
if (foo) {
        let bar = 1;
        console.log(bar);
}
//还有就是典型的for循环
for (var i = 0; i < array.length; i++) {
        const element = array[i];
}
//也就是说i其实只在for循环的块里边使用，所以没有必要暴露到全局，甚至会很危险，
//因为var声明的变量，看似是在for内部声明的，其实相对于for循环来说它跟声明在全局没有什么区别
//let就能很好的解决这个问题，let是es6新增的关键字，跟var的用法一样，声明一个标识符，
//但是他跟var的区别就是，let可以劫持当前的作用域，并且在外部无法调取，比如：
{
        let i = 3;
}
console.log(i);//undefined
//所以说let 跟{}结合可以显示的实现一个块作用域，上面的for循环可以修改为：
for (let i = 0; i < 9; i++) { }
//或者
{
        let j = 0;
        for (let i = 0; i < 9; i++) {
                j = i;
                console.log(j);
        }
}